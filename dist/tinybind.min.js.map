{"version":3,"file":"tinybind.min.js","sources":["../src/constants.js","../src/parsers.js","../src/observer.js","../src/tinybind.js","../src/view.js","../src/binders.js","../src/bindings.js","../src/adapter.js","../src/component.js","../src/export.js","../src/formatters.js"],"sourcesContent":["export const OPTIONS = [\n  'prefix',\n  'templateDelimiters',\n  'rootInterface',\n  'preloadData',\n  'handler'\n]\n\nexport const EXTENSIONS = [\n  'binders',\n  'formatters',\n  'adapters'\n]","const PRIMITIVE = 0\nconst KEYPATH = 1\nconst TEXT = 0\nconst BINDING = 1\n\nconst QUOTED_STR = /^'.*'$|^\".*\"$/\n\n// Parser and tokenizer for getting the type and value from a string.\nexport function parseType(string) {\n  let type = PRIMITIVE\n  let value = string\n\n  if (QUOTED_STR.test(string)) {\n    value = string.slice(1, -1)\n  } else if (string === 'true') {\n    value = true\n  } else if (string === 'false') {\n    value = false\n  } else if (string === 'null') {\n    value = null\n  } else if (string === 'undefined') {\n    value = undefined\n  } else if (!isNaN(string)) {\n    value = Number(string)\n  } else {\n    type = KEYPATH\n  }\n\n  return {type: type, value: value}\n}\n\n// Template parser and tokenizer for mustache-style text content bindings.\n// Parses the template and returns a set of tokens, separating static portions\n// of text from binding declarations.\nexport function parseTemplate(template, delimiters) {\n  var tokens\n  let length = template.length\n  let index = 0\n  let lastIndex = 0\n  let open = delimiters[0], close = delimiters[1]\n\n  while (lastIndex < length) {\n    index = template.indexOf(open, lastIndex)\n\n    if (index < 0) {\n      if (tokens) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex)\n        })\n      }\n\n      break\n    } else {\n      tokens || (tokens = [])\n      if (index > 0 && lastIndex < index) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex, index)\n        })\n      }\n\n      lastIndex = index + open.length\n      index = template.indexOf(close, lastIndex)\n\n      if (index < 0) {\n        let substring = template.slice(lastIndex - close.length)\n        let lastToken = tokens[tokens.length - 1]\n\n        if (lastToken && lastToken.type === TEXT) {\n          lastToken.value += substring\n        } else {\n          tokens.push({\n            type: TEXT,\n            value: substring\n          })\n        }\n\n        break\n      }\n\n      let value = template.slice(lastIndex, index).trim()\n\n      tokens.push({\n        type: BINDING,\n        value: value\n      })\n\n      lastIndex = index + close.length\n    }\n  }\n\n  return tokens\n}\n","\n// Check if a value is an object than can be observed.\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\n// Error thrower.\nfunction error(message) {\n  throw new Error(`[Observer] ${message}`)\n}\n\nlet adapters;\nlet interfaces;\nlet rootInterface;\n\n// Constructs a new keypath observer and kicks things off.\nclass Observer {\n  static updateOptions (options) {\n    adapters = options.adapters\n    interfaces = Object.keys(adapters)\n    rootInterface = options.rootInterface\n  }\n  \n  // Tokenizes the provided keypath string into interface + path tokens for the\n  // observer to work with.\n  static tokenize (keypath, root) {\n    const tokens = [];\n    let current = {i: root, path: ''};\n    let index;\n    let chr;\n  \n    for (index = 0; index < keypath.length; index++) {\n      chr = keypath.charAt(index)\n  \n      if (!!~interfaces.indexOf(chr)) {\n        tokens.push(current)\n        current = {i: chr, path: ''}\n      } else {\n        current.path += chr\n      }\n    }\n  \n    tokens.push(current)\n    return tokens\n  }\n\n  constructor(obj, keypath, callback) {\n    this.keypath = keypath\n    this.callback = callback\n    this.objectPath = []\n    this.parse()\n    this.obj = this.getRootObject(obj)\n\n    if (isObject(this.target = this.realize())) {\n      this.set(true, this.key, this.target, this.callback)\n    }\n  }\n\n  // Parses the keypath using the interfaces defined on the view. Sets variables\n  // for the tokenized keypath as well as the end key.\n  parse() {\n    let path;\n    let root;\n\n    if (!interfaces.length) {\n      error('Must define at least one adapter interface.')\n    }\n\n    if (!!~interfaces.indexOf(this.keypath[0])) {\n      root = this.keypath[0]\n      path = this.keypath.substr(1)\n    } else {\n      root = rootInterface\n      path = this.keypath\n    }\n\n    this.tokens = Observer.tokenize(path, root)\n    this.key = this.tokens.pop()\n  }\n\n  // Realizes the full keypath, attaching observers for every key and correcting\n  // old observers to any changed objects in the keypath.\n  realize() {\n    let current = this.obj;\n    let unreached = -1;\n    let prev;\n    let token;\n\n    for (let index = 0; index < this.tokens.length; index++) {\n      token = this.tokens[index]\n      if (isObject(current)) {\n        if (typeof this.objectPath[index] !== 'undefined') {\n          if (current !== (prev = this.objectPath[index])) {\n            this.set(false, token, prev, this)\n            this.set(true, token, current, this)\n            this.objectPath[index] = current\n          }\n        } else {\n          this.set(true, token, current, this)\n          this.objectPath[index] = current\n        }\n\n        current = this.get(token, current)\n      } else {\n        if (unreached === -1) {\n          unreached = index\n        }\n\n        if (prev = this.objectPath[index]) {\n          this.set(false, token, prev, this)\n        }\n      }\n    }\n\n    if (unreached !== -1) {\n      this.objectPath.splice(unreached)\n    }\n\n    return current\n  }\n\n  // Updates the keypath. This is called when any intermediary key is changed.\n  sync() {\n    let next;\n    let oldValue;\n    let newValue;\n\n    if ((next = this.realize()) !== this.target) {\n      if (isObject(this.target)) {\n        this.set(false, this.key, this.target, this.callback)\n      }\n\n      if (isObject(next)) {\n        this.set(true, this.key, next, this.callback)\n      }\n\n      oldValue = this.value()\n      this.target = next\n      newValue = this.value()\n      if (newValue !== oldValue || newValue instanceof Function) this.callback.sync()\n    } else if (next instanceof Array) {\n      this.callback.sync()\n    }\n  }\n\n  // Reads the current end value of the observed keypath. Returns undefined if\n  // the full keypath is unreachable.\n  value() {\n    if (isObject(this.target)) {\n      return this.get(this.key, this.target)\n    }\n  }\n\n  // Sets the current end value of the observed keypath. Calling setValue when\n  // the full keypath is unreachable is a no-op.\n  setValue(value) {\n    if (isObject(this.target)) {\n      adapters[this.key.i].set(this.target, this.key.path, value)\n    }\n  }\n\n  // Gets the provided key on an object.\n  get(key, obj) {\n    return adapters[key.i].get(obj, key.path);\n  }\n\n  // Observes or unobserves a callback on the object using the provided key.\n  set(active, key, obj, callback) {\n    const action = active ? 'observe' : 'unobserve';\n    adapters[key.i][action](obj, key.path, callback)\n  }\n\n  // Unobserves the entire keypath.\n  unobserve() {\n    let obj;\n    let token;\n\n    for (let index = 0; index < this.tokens.length; index++) {\n      token = this.tokens[index]\n      if (obj = this.objectPath[index]) {\n        this.set(false, token, obj, this)\n      }\n    }\n\n    if (isObject(this.target)) {\n      this.set(false, this.key, this.target, this.callback)\n    }\n  }\n\n  // traverse the scope chain to find the scope which has the root property\n  // if the property is not found in chain, returns the root scope\n  getRootObject(obj) {\n    let rootProp;\n    let current;\n    if (!obj.$parent) {\n      return obj;\n    }\n\n    if (this.tokens.length) {\n      rootProp = this.tokens[0].path\n    } else {\n      rootProp = this.key.path\n    }\n\n    current = obj;\n    while (current.$parent && (current[rootProp] === undefined)) {\n      current = current.$parent\n    }\n\n    return current;\n  }\n}\n\nexport default Observer\n","import {EXTENSIONS} from './constants'\nimport {parseTemplate, parseType} from './parsers'\n\nconst tinybind = {\n  // Global binders.\n  binders: {},\n\n  // Global formatters.\n  formatters: {},\n\n  // Global sightglass adapters.\n  adapters: {},\n\n  // Default attribute prefix.\n  _prefix: 'rv',\n\n  _fullPrefix: 'rv-',\n\n  get prefix () {\n    return this._prefix\n  },\n\n  set prefix (value) {\n    this._prefix = value\n    this._fullPrefix = value + '-'\n  },\n\n  parseTemplate: parseTemplate,\n\n  parseType: parseType,\n\n  // Default template delimiters.\n  templateDelimiters: ['{', '}'],\n\n  // Default sightglass root interface.\n  rootInterface: '.',\n\n  // Preload data by default.\n  preloadData: true,\n\n  // Default event handler.\n  handler: function(context, ev, binding) {\n    this.call(context, ev, binding.view.models)\n  },\n\n  // Sets the attribute on the element. If no binder above is matched it will fall\n  // back to using this binder.\n  fallbackBinder: function(el, value) {\n    if (value != null) {\n      el.setAttribute(this.type, value)\n    } else {\n      el.removeAttribute(this.type)\n    }  \n  },\n\n  // Merges an object literal into the corresponding global options.\n  configure: function(options) {\n    if (!options) {\n      return\n    }\n    Object.keys(options).forEach(option => {\n      let value = options[option]\n\n      if (EXTENSIONS.indexOf(option) > -1) {\n        Object.keys(value).forEach(key => {\n          this[option][key] = value[key]\n        })\n      } else {\n        this[option] = value\n      }\n    })\n  }\n}\n\nexport default tinybind\n","import tinybind from './tinybind'\nimport {Binding} from './bindings'\nimport {parseTemplate} from './parsers'\n\nconst textBinder = {\n  routine: (node, value) => {\n    node.data = (value != null) ? value : ''\n  }\n}\n\nconst DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g\n\nconst parseNode = (view, node) => {\n  let block = false\n\n  if (node.nodeType === 3) {\n    let tokens = parseTemplate(node.data, tinybind.templateDelimiters)\n\n    if (tokens) {\n      for (let i = 0; i < tokens.length; i++) {\n        let token = tokens[i]\n        let text = document.createTextNode(token.value)\n        node.parentNode.insertBefore(text, node)\n\n        if (token.type === 1) {\n          view.buildBinding(text, null, token.value, textBinder, null)\n        }\n      }\n\n      node.parentNode.removeChild(node)\n    }\n    block = true\n  } else if (node.nodeType === 1) {\n    block = view.traverse(node)\n  }\n\n  if (!block) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n      parseNode(view, node.childNodes[i]);\n    }\n  }\n}\n\nconst bindingComparator = (a, b) => {\n  let aPriority = a.binder ? (a.binder.priority || 0) : 0\n  let bPriority = b.binder ? (b.binder.priority || 0) : 0\n  return bPriority - aPriority\n}\n\nconst trimStr = (str) => {\n  return str.trim()\n}\n\n// A collection of bindings built from a set of parent nodes.\nexport default class View {\n  // The DOM elements and the model objects for binding are passed into the\n  // constructor along with any local options that should be used throughout the\n  // context of the view and it's bindings.\n  constructor(els, models, options) {\n    if (els.jquery || els instanceof Array) {\n      this.els = els\n    } else {\n      this.els = [els]\n    }\n\n    this.models = models\n    this.options = options\n\n    this.build()\n  }\n\n\n  buildBinding(node, type, declaration, binder, arg) {\n    let pipes = declaration.match(DECLARATION_SPLIT).map(trimStr)\n\n    let keypath = pipes.shift()\n\n    this.bindings.push(new Binding(this, node, type, keypath, binder, arg, pipes))\n  }\n\n  // Parses the DOM tree and builds `Binding` instances for every matched\n  // binding declaration.\n  build() {\n    this.bindings = []\n\n    let elements = this.els, i, len;\n    for (i = 0, len = elements.length; i < len; i++) {\n      parseNode(this, elements[i])\n    }\n\n    this.bindings.sort(bindingComparator)\n  }\n\n  traverse(node) {\n    let bindingPrefix = tinybind._fullPrefix\n    let block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE'\n    let attributes = node.attributes\n    let bindInfos = []\n    let starBinders = this.options.starBinders\n    var type, binder, identifier, arg\n\n\n    for (let i = 0, len = attributes.length; i < len; i++) {\n      let attribute = attributes[i]\n      if (attribute.name.indexOf(bindingPrefix) === 0) {\n        type = attribute.name.slice(bindingPrefix.length)\n        binder = this.options.binders[type]\n        arg = undefined\n\n        if (!binder) {\n          for (let k = 0; k < starBinders.length; k++) {\n            identifier = starBinders[k]\n            if (type.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\n              binder = this.options.binders[identifier]\n              arg = type.slice(identifier.length - 1)\n              break\n            }\n          }\n        }\n\n        if (!binder) {\n          binder = tinybind.fallbackBinder\n        }\n\n        if (binder.block) {\n          this.buildBinding(node, type, attribute.value, binder, arg)\n          node.removeAttribute(attribute.name)\n          return true;\n        }\n\n        bindInfos.push({attr: attribute, binder: binder, type: type, arg: arg})\n      }\n    }\n\n    for (let i = 0; i < bindInfos.length; i++) {\n      let bindInfo = bindInfos[i]\n      this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.arg)\n      node.removeAttribute(bindInfo.attr.name)\n    }\n\n    return block\n  }\n\n  // Binds all of the current bindings for this view.\n  bind() {\n    this.bindings.forEach(binding => {\n      binding.bind()\n    })\n  }\n\n  // Unbinds all of the current bindings for this view.\n  unbind() {\n    this.bindings.forEach(binding => {\n      binding.unbind()\n    })\n  }\n\n  // Syncs up the view with the model by running the routines on all bindings.\n  sync() {\n    this.bindings.forEach(binding => {\n      binding.sync()\n    })\n  }\n\n  // Publishes the input values from the view back to the model (reverse sync).\n  publish() {\n    this.bindings.forEach(binding => {\n      if (binding.binder && binding.binder.publishes) {\n        binding.publish()\n      }\n    })\n  }\n\n  // Updates the view's models along with any affected bindings.\n  update(models = {}) {\n    Object.keys(models).forEach(key => {\n      this.models[key] = models[key]\n    })\n\n    this.bindings.forEach(binding => {\n      if (binding.update) {\n        binding.update(models)\n      }\n    })\n  }\n}\n","import View from './view'\n\nconst getString = (value) => {\n  return value != null ? value.toString() : undefined\n}\n\nconst times = (n, cb) => {\n  for (let i = 0; i < n; i++) cb()\n}\n\nfunction createView(binding, data, anchorEl) {\n  let template = binding.el.cloneNode(true)\n  let view = new View(template, data, binding.view.options)\n  view.bind()\n  binding.marker.parentNode.insertBefore(template, anchorEl)\n  return view\n}\n\nconst binders = {\n  // Binds an event handler on the element.\n  'on-*': {\n    function: true,\n    priority: 1000,\n\n    unbind: function(el) {\n      if (this.handler) {\n        el.removeEventListener(this.arg, this.handler)\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.handler) {\n        el.removeEventListener(this.arg, this.handler)\n      }\n\n      this.handler = this.eventHandler(value)\n      el.addEventListener(this.arg, this.handler)\n    }\n  },\n\n  // Appends bound instances of the element in place for each item in the array.\n  'each-*': {\n    block: true,\n\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(` tinybind: ${this.type} `)\n        this.iterated = []\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else {\n        this.iterated.forEach(view => {\n          view.bind()\n        })\n      }\n    },\n\n    unbind: function(el) {\n      if (this.iterated) {\n        this.iterated.forEach(view => {\n          view.unbind()\n        })\n      }\n    },\n\n    routine: function(el, collection) {\n      let modelName = this.arg\n      collection = collection || []\n      let indexProp = el.getAttribute('index-property') || '$index'\n\n      collection.forEach((model, index) => {\n        let data = {$parent: this.view.models}\n        data[indexProp] = index\n        data[modelName] = model\n        let view = this.iterated[index]\n\n        if (!view) {\n\n          let previous = this.marker\n\n          if (this.iterated.length) {\n            previous = this.iterated[this.iterated.length - 1].els[0]\n          }\n\n          view = createView(this, data, previous.nextSibling)\n          this.iterated.push(view)\n        } else {\n          if (view.models[modelName] !== model) {\n            // search for a view that matches the model\n            let matchIndex, nextView\n            for (let nextIndex = index + 1; nextIndex < this.iterated.length; nextIndex++) {\n              nextView = this.iterated[nextIndex]\n              if (nextView.models[modelName] === model) {\n                matchIndex = nextIndex\n                break\n              }\n            }\n            if (matchIndex !== undefined) {\n              // model is in other position\n              // todo: consider avoiding the splice here by setting a flag\n              // profile performance before implementing such change\n              this.iterated.splice(matchIndex, 1)\n              this.marker.parentNode.insertBefore(nextView.els[0], view.els[0])\n              nextView.models[indexProp] = index\n            } else {\n              //new model\n              nextView = createView(this, data, view.els[0])\n            }\n            this.iterated.splice(index, 0, nextView)\n          } else {\n            view.models[indexProp] = index\n          }\n        }\n      })\n\n      if (this.iterated.length > collection.length) {\n        times(this.iterated.length - collection.length, () => {\n          let view = this.iterated.pop()\n          view.unbind()\n          this.marker.parentNode.removeChild(view.els[0])\n        })\n      }\n\n      if (el.nodeName === 'OPTION') {\n        this.view.bindings.forEach(binding => {\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\n            binding.sync()\n          }\n        })\n      }\n    },\n\n    update: function(models) {\n      let data = {}\n\n      //todo: add test and fix if necessary\n\n      Object.keys(models).forEach(key => {\n        if (key !== this.arg) {\n          data[key] = models[key]\n        }\n      })\n\n      this.iterated.forEach(view => {\n        view.update(data)\n      })\n    }\n  },\n\n  // Adds or removes the class from the element when value is true or false.\n  'class-*': function(el, value) {\n    let elClass = ` ${el.className} `\n\n    if (!value === (elClass.indexOf(` ${this.arg} `) > -1)) {\n      if (value) {\n        el.className = `${el.className} ${this.arg}`\n      } else {\n        el.className = elClass.replace(` ${this.arg} `, ' ').trim()\n      }\n    }\n  },\n\n  // Sets the element's text value.\n  text: (el, value) => {\n    el.textContent = value != null ? value : ''\n  },\n\n  // Sets the element's HTML content.\n  html: (el, value) => {\n    el.innerHTML = value != null ? value : ''\n  },\n\n  // Shows the element when value is true.\n  show: (el, value) => {\n    el.style.display = value ? '' : 'none'\n  },\n\n  // Hides the element when value is true (negated version of `show` binder).\n  hide: (el, value) => {\n    el.style.display = value ? 'none' : ''\n  },\n\n  // Enables the element when value is true.\n  enabled: (el, value) => {\n    el.disabled = !value\n  },\n\n  // Disables the element when value is true (negated version of `enabled` binder).\n  disabled: (el, value) => {\n    el.disabled = !!value\n  },\n\n  // Checks a checkbox or radio input when the value is true. Also sets the model\n  // property when the input is checked or unchecked (two-way binder).\n  checked: {\n    publishes: true,\n    priority: 2000,\n\n    bind: function(el) {\n      var self = this;\n      if (!this.callback) {\n        this.callback = function () {\n          self.publish();\n        }\n      }\n      el.addEventListener('change', this.callback)\n    }, \n\n    unbind: function(el) {\n      el.removeEventListener('change', this.callback)\n    },\n\n    routine: function(el, value) {\n      if (el.type === 'radio') {\n        el.checked = getString(el.value) === getString(value)\n      } else {\n        el.checked = !!value\n      }\n    }\n  },\n\n  // Sets the element's value. Also sets the model property when the input changes\n  // (two-way binder).\n  value: {\n    publishes: true,\n    priority: 3000,\n\n    bind: function(el) {\n      this.isRadio = el.tagName === 'INPUT' && (el.type === 'radio' || el.type === 'checkbox');\n      if (!this.isRadio) {\n        this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input')\n\n        var self = this;\n        if (!this.callback) {\n          this.callback = function () {\n            self.publish();\n          }\n        }\n        el.addEventListener(this.event, this.callback)\n      }\n    },\n\n    unbind: function(el) {\n      if (!this.isRadio) {\n        el.removeEventListener(this.event, this.callback)\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.isRadio) {\n        el.setAttribute('value', value)\n      } else {\n        if (el.type === 'select-multiple') {\n          if (value instanceof Array) {\n            for (let i = 0; i < el.length; i++) {\n              let option = el[i];\n              option.selected = value.indexOf(option.value) > -1\n            }\n          }\n        } else if (getString(value) !== getString(el.value)) {\n          el.value = value != null ? value : ''\n        }\n      }\n    }\n  },\n\n  // Inserts and binds the element and it's child nodes into the DOM when true.\n  if: {\n    block: true,\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(' tinybind: ' + this.type + ' ' + this.keypath + ' ');\n        this.attached = false\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else if (this.bound === false && this.nested) {\n        this.nested.bind()\n      }\n      this.bound = true\n    },\n\n    unbind: function() {\n      if (this.nested) {\n        this.nested.unbind()\n        this.bound = false\n      }\n    },\n\n    routine: function(el, value) {\n      if (!!value !== this.attached) {\n        if (value) {\n\n          if (!this.nested) {\n            this.nested = new View(el, this.view.models, this.view.options)\n            this.nested.bind()\n          }\n\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling)\n          this.attached = true\n        } else {\n          el.parentNode.removeChild(el)\n          this.attached = false\n        }\n      }\n    },\n\n    update: function(models) {\n      if (this.nested) {\n        this.nested.update(models)\n      }\n    }\n  }\n}\n\nexport default binders\n","import { parseType } from './parsers'\nimport Observer from './observer'\n\nfunction getInputValue(el) {\n  if (el.type === 'checkbox') {\n    return el.checked\n  } else if (el.type === 'select-multiple') {\n    const results = []\n    let option\n    for (let i = 0; i < el.options.length; i++) {\n      option = el.options[i]\n      if (option.selected) {\n        results.push(option.value);\n      }\n    }\n    return results\n  } else {\n    return el.value\n  }\n}\n\nconst FORMATTER_ARGS = /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g\nconst FORMATTER_SPLIT = /\\s+/\n\n// A single binding between a model attribute and a DOM element.\nexport class Binding {\n  // All information about the binding is passed into the constructor; the\n  // containing view, the DOM node, the type of binding, the model object and the\n  // keypath at which to listen for changes.\n  constructor(view, el, type, keypath, binder, arg, formatters) {\n    this.view = view\n    this.el = el\n    this.type = type\n    this.keypath = keypath\n    this.binder = binder\n    this.arg = arg\n    this.formatters = formatters\n    this.formatterObservers = {}\n    this.model = undefined\n  }\n\n  // Observes the object keypath\n  observe(obj, keypath) {\n    return new Observer(obj, keypath, this)\n  }\n\n  parseTarget() {\n    if (this.keypath) {\n      let token = parseType(this.keypath)\n      if (token.type === 0) {\n        this.value = token.value\n      } else {\n        this.observer = this.observe(this.view.models, this.keypath)\n        this.model = this.observer.target\n      }\n    } else {\n      this.value = undefined;\n    }\n  }\n\n  parseFormatterArguments(args, formatterIndex) {\n    return args\n      .map(parseType)\n      .map(({ type, value }, ai) => {\n        if (type === 0) {\n          return value\n        } else {\n          if (!this.formatterObservers[formatterIndex]) {\n            this.formatterObservers[formatterIndex] = {}\n          }\n\n          let observer = this.formatterObservers[formatterIndex][ai]\n\n          if (!observer) {\n            observer = this.observe(this.view.models, value)\n            this.formatterObservers[formatterIndex][ai] = observer\n          }\n\n          return observer.value()\n        }\n      })\n  }\n\n  // Applies all the current formatters to the supplied value and returns the\n  // formatted value.\n  formattedValue(value) {\n    return this.formatters.reduce((result, declaration, index) => {\n      let args = declaration.match(FORMATTER_ARGS)\n      let id = args.shift()\n      let formatter = this.view.options.formatters[id]\n\n      const processedArgs = this.parseFormatterArguments(args, index)\n\n      if (formatter && (formatter.read instanceof Function)) {\n        result = formatter.read(result, ...processedArgs)\n      } else if (formatter instanceof Function) {\n        result = formatter(result, ...processedArgs)\n      }\n      return result\n    }, value)\n  }\n\n  // Returns an event handler for the binding around the supplied function.\n  eventHandler(fn) {\n    let binding = this\n    let handler = binding.view.options.handler\n\n    return function (ev) {\n      handler.call(fn, this, ev, binding)\n    }\n  }\n\n  // Sets the value for the binding. This Basically just runs the binding routine\n  // with the supplied value formatted.\n  set(value) {\n    if ((value instanceof Function) && !this.binder.function) {\n      value = this.formattedValue(value.call(this.model))\n    } else {\n      value = this.formattedValue(value)\n    }\n\n    let routineFn = this.binder.routine || this.binder\n\n    if (routineFn instanceof Function) {\n      routineFn.call(this, this.el, value)\n    }\n  }\n\n  // Syncs up the view binding with the model.\n  sync() {\n    if (this.observer) {\n      this.model = this.observer.target\n      this.set(this.observer.value())\n    } else {\n      this.set(this.value)\n    }\n  }\n\n  // Publishes the value currently set on the input element back to the model.\n  publish() {\n    if (this.observer) {\n      var value = this.formatters.reduceRight((result, declaration, index) => {\n        const args = declaration.split(FORMATTER_SPLIT)\n        const id = args.shift()\n        const formatter = this.view.options.formatters[id]\n        const processedArgs = this.parseFormatterArguments(args, index)\n\n        if (formatter && formatter.publish) {\n          result = formatter.publish(result, ...processedArgs)\n        }\n        return result\n      }, this.getValue(this.el))\n      this.observer.setValue(value)\n    }\n  }\n\n  // Subscribes to the model for changes at the specified keypath. Bi-directional\n  // routines will also listen for changes on the element to propagate them back\n  // to the model.\n  bind() {\n    this.parseTarget()\n\n    if (this.binder.hasOwnProperty('bind')) {\n      this.binder.bind.call(this, this.el)\n    }\n\n    if (this.view.options.preloadData) {\n      this.sync()\n    }\n  }\n\n  // Unsubscribes from the model and the element.\n  unbind() {\n    if (this.binder.unbind) {\n      this.binder.unbind.call(this, this.el)\n    }\n\n    if (this.observer) {\n      this.observer.unobserve()\n    }\n\n    Object.keys(this.formatterObservers).forEach(fi => {\n      let args = this.formatterObservers[fi]\n\n      Object.keys(args).forEach(ai => {\n        args[ai].unobserve()\n      })\n    })\n\n    this.formatterObservers = {}\n  }\n\n  // Updates the binding's model from what is currently set on the view. Unbinds\n  // the old model first and then re-binds with the new model.\n  update(models = {}) {\n    if (this.observer) {\n      this.model = this.observer.target\n    }\n\n    if (this.binder.update) {\n      this.binder.update.call(this, models)\n    }\n  }\n\n  // Returns elements value\n  getValue(el) {\n    if (this.binder && this.binder.getValue) {\n      return this.binder.getValue.call(this, el)\n    } else {\n      return getInputValue(el)\n    }\n  }\n}\n","// The default `.` adapter that comes with tinybind.js. Allows subscribing to\n// properties on plain objects, implemented in ES5 natives using\n// `Object.defineProperty`.\n\nconst ARRAY_METHODS = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n]\n\nconst adapter = {\n  counter: 0,\n  weakmap: {},\n\n  weakReference: function(obj) {\n    if (!obj.hasOwnProperty('__rv')) {\n      let id = this.counter++\n\n      Object.defineProperty(obj, '__rv', {\n        value: id\n      })\n    }\n\n    if (!this.weakmap[obj.__rv]) {\n      this.weakmap[obj.__rv] = {\n        callbacks: {}\n      }\n    }\n\n    return this.weakmap[obj.__rv]\n  },\n\n  cleanupWeakReference: function(data, refId) {\n    if (!Object.keys(data.callbacks).length) {\n      if (!(data.pointers && Object.keys(data.pointers).length)) {\n        delete this.weakmap[refId]\n      }\n    }\n  },\n\n  stubFunction: function(obj, fn) {\n    const original = obj[fn]\n    const data = this.weakReference(obj)\n    const weakmap = this.weakmap\n\n    obj[fn] = (...args) => {\n      let response = original.apply(obj, args)\n\n      Object.keys(data.pointers).forEach(refId => {\n        let k = data.pointers[refId]\n\n        if (weakmap[refId]) {\n          if (weakmap[refId].callbacks[k] instanceof Array) {\n            weakmap[refId].callbacks[k].forEach(callback => {\n              callback.sync()\n            })\n          }\n        }\n      })\n\n      return response\n    }\n  },\n\n  observeArray: function(value, refId, keypath) {\n    if (value instanceof Array) {\n      let data = this.weakReference(value)\n\n      if (!data.pointers) {\n        data.pointers = {}\n\n        ARRAY_METHODS.forEach(fn => {\n          this.stubFunction(value, fn)\n        })\n      }\n\n      if (!data.pointers[refId]) {\n        data.pointers[refId] = []\n      }\n\n      if (data.pointers[refId].indexOf(keypath) === -1) {\n        data.pointers[refId].push(keypath)\n      }\n    }\n  },\n\n  unobserveArray: function(value, refId, keypath) {\n    if ((value instanceof Array) && (value.__rv != null)) {\n      let data = this.weakmap[value.__rv]\n\n      if (data) {\n        let pointers = data.pointers[refId]\n\n        if (pointers) {\n          let idx = pointers.indexOf(keypath)\n\n          if (idx > -1) {\n            pointers.splice(idx, 1)\n          }\n\n          if (!pointers.length) {\n            delete data.pointers[refId]\n          }\n\n          this.cleanupWeakReference(data, value.__rv)\n        }\n      }\n    }\n  },\n\n  observe: function(obj, keypath, callback) {\n    let value    \n    const callbacks = this.weakReference(obj).callbacks\n\n    if (!callbacks[keypath]) {\n      callbacks[keypath] = []\n      let desc = Object.getOwnPropertyDescriptor(obj, keypath)\n\n      if (!desc || !(desc.get || desc.set || !desc.configurable)) {\n        value = obj[keypath]\n\n        Object.defineProperty(obj, keypath, {\n          enumerable: true,\n\n          get: () => {\n            return value\n          },\n\n          set: newValue => {\n            if (newValue !== value) {\n              this.unobserveArray(value, obj.__rv, keypath)\n              value = newValue\n              const data = this.weakmap[obj.__rv]\n\n              if (data) {\n                let callbacks = data.callbacks[keypath]\n\n                if (callbacks) {\n                  callbacks.forEach(cb => {\n                      cb.sync()\n                  })\n                }\n\n                this.observeArray(newValue, obj.__rv, keypath)\n              }\n            }\n          }\n        })\n      }\n    }\n\n    if (callbacks[keypath].indexOf(callback) === -1) {\n      callbacks[keypath].push(callback)\n    }\n\n    this.observeArray(obj[keypath], obj.__rv, keypath)\n  },\n\n  unobserve: function(obj, keypath, callback) {\n    let data = this.weakmap[obj.__rv]\n\n    if (data) {\n      let callbacks = data.callbacks[keypath]\n\n      if (callbacks) {\n        let idx = callbacks.indexOf(callback)\n\n        if (idx > -1) {\n          callbacks.splice(idx, 1)\n\n          if (!callbacks.length) {\n            delete data.callbacks[keypath]\n            this.unobserveArray(obj[keypath], obj.__rv, keypath)\n          }\n        }\n\n        this.cleanupWeakReference(data, obj.__rv)\n      }\n    }\n  },\n\n  get: function(obj, keypath) {\n    return obj[keypath]\n  },\n\n  set: (obj, keypath, value) => {\n    obj[keypath] = value\n  }\n}\n\nexport default adapter\n","\nimport tinybind from './tinybind'\n\nclass Component extends HTMLElement {\n  static get observedAttributes() {\n    const template = this.template\n    if (!template) {\n      throw new Error(`No template declared for ${this.name}`)\n    }\n\n    this.__templateEl = document.createElement('template')\n    this.__templateEl.innerHTML = template\n    \n    const propAttributeMap = this.__propAttributeMap = {}\n    const attributes = []\n    const properties = this.properties\n    if (properties) {\n      Object.keys(properties).forEach(propName => {\n        const propConfig = properties[propName]\n        const attrName = typeof propConfig === 'string' ? propConfig : propName\n        propAttributeMap[attrName] = propName\n        attributes.push(attrName)\n      })\n    }    \n    return attributes\n  }\n\n  connectedCallback() {\n    const nodes = this.constructor.__templateEl.content.cloneNode(true)\n    this.__tinybindView = tinybind.bind(nodes, this)    \n    while (this.firstChild) {\n      this.removeChild(this.firstChild);\n    }\n    this.appendChild(nodes)\n  }\n\n  disconnectedCallback() {\n    this.__tinybindView.unbind()    \n  }\n\n  attributeChangedCallback(name, old, value) {\n    if (old !== value) {      \n      const propName = this.constructor.__propAttributeMap[name]\n      this[propName] = value\n    }\n  }  \n}\n\nexport default Component","import tinybind from './tinybind'\nimport View from './view'\nimport {OPTIONS, EXTENSIONS} from './constants'\nimport adapter from './adapter'\nimport binders from './binders'\nimport formatters from './formatters'\nimport Observer from './observer'\nimport Component from './component'\n\n// Returns the public interface.\n\ntinybind.binders = binders\ntinybind.formatters = formatters\ntinybind.adapters['.'] = adapter\ntinybind.Component = Component\n\n// Binds some data to a template / element. Returns a tinybind.View instance.\ntinybind.bind = (el, models, options) => {\n  let viewOptions = {}\n  models = models || {}\n  options = options || {}\n\n  EXTENSIONS.forEach(extensionType => {\n    viewOptions[extensionType] = Object.create(null)\n\n    if (options[extensionType]) {\n      Object.keys(options[extensionType]).forEach(key => {\n        viewOptions[extensionType][key] = options[extensionType][key]\n      })\n    }\n\n    Object.keys(tinybind[extensionType]).forEach(key => {\n      if (!viewOptions[extensionType][key]) {\n        viewOptions[extensionType][key] = tinybind[extensionType][key]\n      }\n    })\n  })\n\n  OPTIONS.forEach(option => {\n    let value = options[option]\n    viewOptions[option] = value != null ? value : tinybind[option]\n  })\n\n  viewOptions.starBinders = Object.keys(viewOptions.binders).filter(function (key) {\n    return key.indexOf('*') > 0\n  })\n\n  Observer.updateOptions(viewOptions)\n\n  let view = new View(el, models, viewOptions)\n  view.bind()\n  return view\n}\n\nexport default tinybind\n","const formatters = {\n  watch: function(value) {\n    return value;\n  },\n\n  not: function(value) {\n    return !value;\n  },\n\n  negate: function(value) {\n    return !value;\n  }\n}\n\nexport default formatters"],"names":["OPTIONS","EXTENSIONS","QUOTED_STR","parseType","string","type","value","test","slice","undefined","isNaN","Number","parseTemplate","template","delimiters","tokens","index","length","lastIndex","open","close","indexOf","push","substring","lastToken","trim","adapters","interfaces","rootInterface","tinybind","binders","formatters","_prefix","_fullPrefix","prefix","this","templateDelimiters","preloadData","handler","context","ev","binding","call","view","models","fallbackBinder","el","setAttribute","removeAttribute","configure","options","Object","keys","forEach","option","key","_this","isObject","obj","Observer","keypath","callback","objectPath","parse","getRootObject","target","realize","set","updateOptions","tokenize","root","chr","current","i","path","charAt","_proto","Error","substr","pop","prev","token","unreached","get","splice","sync","next","oldValue","newValue","Function","Array","setValue","active","unobserve","rootProp","$parent","parseNode","node","block","nodeType","data","text","document","createTextNode","parentNode","insertBefore","buildBinding","textBinder","removeChild","traverse","childNodes","bindingComparator","a","b","aPriority","binder","priority","trimStr","str","getString","toString","FORMATTER_ARGS","FORMATTER_SPLIT","Binding","arg","formatterObservers","model","observe","parseTarget","observer","parseFormatterArguments","args","formatterIndex","map","ai","formattedValue","reduce","result","declaration","match","id","shift","formatter","_this2","processedArgs","read","eventHandler","fn","function","routineFn","routine","publish","reduceRight","split","_this3","getValue","bind","hasOwnProperty","unbind","fi","_this4","update","getInputValue","checked","results","selected","DECLARATION_SPLIT","View","els","jquery","build","pipes","bindings","elements","len","sort","identifier","bindingPrefix","nodeName","attributes","bindInfos","starBinders","attribute","name","k","attr","bindInfo","publishes","ARRAY_METHODS","adapter","counter","weakmap","weakReference","defineProperty","__rv","callbacks","cleanupWeakReference","refId","pointers","stubFunction","original","response","apply","observeArray","unobserveArray","idx","desc","getOwnPropertyDescriptor","configurable","enumerable","cb","createView","anchorEl","cloneNode","marker","on-*","removeEventListener","addEventListener","each-*","iterated","createComment","collection","modelName","indexProp","getAttribute","matchIndex","nextView","nextIndex","previous","nextSibling","times","n","class-*","elClass","className","replace","textContent","html","innerHTML","show","style","display","hide","enabled","disabled","self","isRadio","tagName","event","if","bound","nested","attached","Component","connectedCallback","nodes","constructor","__templateEl","content","__tinybindView","firstChild","appendChild","disconnectedCallback","attributeChangedCallback","old","__propAttributeMap","createElement","propAttributeMap","properties","propName","propConfig","attrName","HTMLElement","watch","not","negate","viewOptions","extensionType","create","filter"],"mappings":"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"}